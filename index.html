<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8">
    <title>Webcam motion tracking</title>
    <link rel="stylesheet" type="text/css" href="main.css" media="all">
</head>
  
<body>
    <div class='row'>
        <div id='left'>
            <video autoplay="true" id="webCamWindow"></video>
            <div id="movement"></div>
        </div>
        <div id='right'>
            <canvas id="shaderCanvas"></canvas>
        </div>
    </div>
    <script id="vertexShaderCode" type="notjs">
        attribute vec3 a_position;

        void main() {
            gl_Position = vec4(a_position, 1.0);
        }
    </script>
            
    <script id="fragmentShaderCode" type="notjs">
            
        precision mediump float;
        
        // uniforms sent from JS side 
        uniform float u_time;
        uniform vec2 u_resolution;
        uniform vec2 point;
        uniform float wid;
        uniform float hei;

        const float PI = 3.14159;
        const float THICKNESS = 0.4;
        uniform sampler2D backbuffer;


        float THICK = THICKNESS * wid;

        float plot(vec2 uv, float fn){
        return  smoothstep( fn-THICK, fn, uv.y) -
                smoothstep( fn, fn+THICK, uv.y);
        }
        
        float Hash( vec2 p,  float s)
        {
            vec3 p2 = vec3(p.xy,10.0 * abs(sin(s)));
            return fract(sin(dot(p2,vec3(27.1,61.7, 12.4)))*273758.5453123);
        }
        
        float noise(vec2 p, float s)
        {
            vec2 i = floor(p);
            vec2 f = fract(p);
            f *= f * f * (3.0-2.0*f);
        
            return mix(mix(Hash(i + vec2(0.,0.), s), Hash(i + vec2(1.,0.), s),f.x),
                    mix(Hash(i + vec2(0.,1.), s), Hash(i + vec2(1.,1.), s),f.x),
                    f.y) * s;
        }
        
        float factor(float len, float s, float e){
            float v1 = 1.0 - 1.0 / exp(pow((s-len) * 6.0,2.0));
            v1 = clamp(v1, 0.0, 1.0);
            float v2 = 1.0 - 1.0 / exp(pow((len-e) * 6.0,2.0));
            v2 = clamp(v2, 0.0, 1.0);
            return (1.0-step(len,s))*v1 * (step(len,e))*v2;
        }
        
        float fbm(vec2 uv,float t,float len){
            float v = 0.0;
            vec2 p = uv+t;
            v += noise(p*.5, 0.35);
            v -= noise(p*2., 0.25);
            v -= noise(p*4., 0.125);
            v += noise(p*8., 0.0625);
            return v*factor(length(uv),0.0,len);
        }
        
        vec2 rotate(vec2 uv,float degree){
            mat2 rot = mat2(cos(degree),-sin(degree),sin(degree),cos(degree));
            return rot*uv;
        }
        
        void main( void ) {
            float size = min(u_resolution.x, u_resolution.y);
            vec2 uv = gl_FragCoord.xy / size * 2.0 - u_resolution/size;
            uv.x *= u_resolution.y/ u_resolution.x;
            vec2 touch = 2.0 * point  - vec2(1.0);
            uv = rotate(uv,atan(touch.y,touch.x));
            
            float timeMult = 0.5;


            
            vec3 finalColor; 
            float t = 0.02 / distance(uv, vec2(clamp(uv.x,0.0,length(touch)),fbm(uv,u_time*timeMult,length(touch))));
            
            finalColor = 0.9 * texture2D(backbuffer,gl_FragCoord.xy / u_resolution).rgb + t * vec3( 0.2, 0.3, 0.5 );
            
            
            gl_FragColor =  vec4( finalColor, 1.0 );
        
        }
            
    </script>

    <script src="app.js"></script>
    <script src="global.js"></script>
    <script src="webcam.js"></script>
    <script src="compare.js"></script>
    <script src="core.js"></script>
    <script src="main.js"></script>
</body>
</html>